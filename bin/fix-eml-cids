#!/usr/bin/env ruby
# frozen_string_literal: true

# Post-processes EML files extracted by readpst to fix issues:
#
# 1. Content-ID mismatches: readpst generates new UUIDs instead of preserving
#    original Outlook CIDs (e.g., image001.png@01DB76E3.9F21AE40).
#
# 2. Malformed filenames: readpst creates Content-Disposition headers with
#    embedded newlines in filenames, corrupting MIME structure.
#
# Usage: bin/fix-eml-cids <eml-file-or-directory>

require "fileutils"

class EmlCidFixer
  # Match cid references in HTML like: src="cid:image001.png@01DB76E3.9F21AE40"
  CID_PATTERN = /cid:(image\d+\.[a-z]+@[A-F0-9.]+)/i

  # Match Content-ID headers with UUID format (generated by readpst)
  UUID_CID_PATTERN = /^(Content-ID:\s*<)([0-9a-f-]{36})(>)$/i

  def initialize(path)
    @path = path
  end

  def fix_all
    if File.directory?(@path)
      eml_files = Dir.glob(File.join(@path, "**/*.eml"))
      puts "Processing #{eml_files.count} EML files..."

      fixed = 0
      eml_files.each do |file|
        fixed += 1 if fix_file(file)
      end

      puts "Fixed Content-IDs in #{fixed} files"
    else
      fix_file(@path)
    end
  end

  private

  def fix_file(file_path)
    content = File.read(file_path, encoding: "binary")
    new_content = content.dup
    fixes = []

    # Fix 1: Malformed filenames with embedded newlines
    # Pattern: filename="...\n...\n..." -> filename="... ... ..."
    filename_fixes = fix_malformed_filenames(new_content)
    fixes << "#{filename_fixes} filenames" if filename_fixes > 0

    # Fix 2: UUID Content-IDs -> original Outlook CIDs
    cid_fixes = fix_content_ids(new_content)
    fixes << "#{cid_fixes} CIDs" if cid_fixes > 0

    if new_content != content
      File.write(file_path, new_content)
      puts "  Fixed: #{File.basename(file_path)} (#{fixes.join(', ')})"
      true
    else
      false
    end
  end

  def fix_malformed_filenames(content)
    count = 0
    # Match filename="..." where ... may contain newlines
    content.gsub!(/filename="([^"]*\n[^"]*)"/) do |match|
      count += 1
      fixed = $1.gsub(/\s*\n\s*/, " ").strip
      "filename=\"#{fixed}\""
    end
    count
  end

  def fix_content_ids(content)
    original_cids = extract_original_cids(content)
    return 0 if original_cids.empty?

    uuid_cids = extract_uuid_cids(content)
    return 0 if uuid_cids.empty?

    replacements = build_replacements(uuid_cids, original_cids)
    return 0 if replacements.empty?

    replacements.each do |uuid, original|
      content.gsub!("<#{uuid}>", "<#{original}>")
    end

    replacements.count
  end

  def extract_original_cids(content)
    # Find HTML part and extract CID references
    cids = []
    content.scan(CID_PATTERN) do |match|
      cid = match[0]
      cids << cid unless cids.include?(cid)
    end
    cids
  end

  def extract_uuid_cids(content)
    # Find Content-ID headers with UUID format
    uuids = []
    content.scan(/Content-ID:\s*<([0-9a-f-]{36})>/i) do |match|
      uuids << match[0]
    end
    uuids
  end

  def build_replacements(uuid_cids, original_cids)
    replacements = {}

    # Sort original CIDs by image number (image001, image002, etc.)
    sorted_originals = original_cids.sort_by do |cid|
      cid.match(/image(\d+)/i)&.[](1).to_i
    end

    # Match UUIDs to originals by position
    uuid_cids.each_with_index do |uuid, index|
      break if index >= sorted_originals.length
      replacements[uuid] = sorted_originals[index]
    end

    replacements
  end
end

if ARGV.empty?
  puts "Usage: #{$0} <eml-file-or-directory>"
  puts "Example: #{$0} db/seeds/emails"
  exit 1
end

path = ARGV[0]
unless File.exist?(path)
  puts "Error: Path not found: #{path}"
  exit 1
end

EmlCidFixer.new(path).fix_all
